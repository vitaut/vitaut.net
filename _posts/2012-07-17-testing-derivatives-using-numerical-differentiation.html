---
layout: post
title: Testing derivatives using numerical differentiation
date: 2012-07-17
---

<h1>{{ page.title }}</h1>

<div class='post'>
  <script src=
  "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>

  <p>I've been working recently on the <a href="http://www.ampl.com">AMPL</a>
  interface for the <a href="http://www.gnu.org/software/gsl/">GNU Scientific
  Library</a>. Adding a function to AMPL normally requires providing first and
  second partial derivatives for it. Computing the derivatives is
  straightforward and there are plenty of tools, such as <a href=
  "http://www.wolframalpha.com/">Wolfram Alpha</a>, that automate this.
  However, transferring this to code is a tedious and error-prone process.</p>

  <p>For example, consider the function <a href=
  "http://www.gnu.org/software/gsl/manual/html_node/Regular-Modified-Cylindrical-Bessel-Functions.html">
  <code>gsl_sf_bessel_I0_scaled(double x)</code></a> which is defined as
  \(e^{-|x|} I_0(x)\), where \(I_0(x)\) is the <a href=
  "http://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions_:_I.CE.B1.2C_K.CE.B1">
  regular modified cylindrical Bessel function</a> of zeroth order. It has a
  simple derivative:</p>

  <p>\( e^{-|x|} I_1(x)- \frac{x}{|x|} e^{-|x|} I_0(x) \)</p>

  <p>The derivative can be expressed even in a more compact form using
  \(I_0(x)\) and \(I_1(x)\) scaled by \(e^{-|x|}\),
  <code>gsl_sf_bessel_I0_scaled</code> and
  <code>gsl_sf_bessel_I1_scaled</code>.</p>

  <p>Transferring this into C results in the following small program:</p>

{% highlight c %}
#include <math.h>
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>

double I0_scaled_deriv(double x) {
  return gsl_sf_bessel_I1_scaled(x) -
    x * gsl_sf_bessel_I0_scaled(x) / abs(x);
}

int main() {
  printf("%g\n", I0_scaled_deriv(1.5));
  return 0;
}
{% endhighlight %}

  <p>Let's compile and run the program:</p>

<pre class="terminal">
<code>$ gcc -pedantic -Wall -Wextra test.c -lgsl -lgslcblas -otest
$ ./test 
-0.332111
</code></pre>

  <p>It is <a href=
  "http://www.wolframalpha.com/input/?i=d%2Fdx+exp%28-%7Cx%7C%29+I_0%28x%29+at+1.5">
  easy to check</a> that the printed value is incorrect, <code>-0.148394</code>
  should be printed instead. Can you spot the error?</p>

  <p><a href="javascript:;" onclick=
  "javascript:ShowHide('HiddenDiv')">Show/Hide the answer</a></p>

  <div class="mid" id="HiddenDiv" style="DISPLAY: none">
    The issue here is that the <code>abs</code> function operates on integers,
    so the floating-point argument <code>1.5</code> is silently converted into
    the integer <code>1</code> by discarding the fractional part. It can be
    trivially fixed by replacing <code>abs</code> with <code>fabs</code>.
    Unfortunately GCC doesn't give any warning even with <code>-Wall</code> and
    <code>-Wextra</code> options, although there is an option called
    <code>-Wconversion</code> that makes GCC warn you of this kind of problems.
  </div><script language="JavaScript">
function ShowHide(divId) {   if(document.getElementById(divId).style.display == 'none') {     document.getElementById(divId).style.display='block';   } else {     document.getElementById(divId).style.display = 'none';   } } 
  </script>

  <p>This small example demonstrates how important it is to test the code.
  Unfortunately it is rarely discussed in the context of OR. As Tim Hopper put
  it in his recent <a href=
  "http://www.stiglerdiet.com/2012/07/12/operations-research-and-computer-programming/">
  blog post</a>:</p>

  <blockquote>
    Code testing was never mentioned in any of my classes in college, and I
    never hear operations researchers talk about it. Again, I have no doubt
    that the code behind much published work is full of mistakes. Operations
    researchers need good testing practices?
  </blockquote>

  <p>Returning to the question of derivatives, how do you actually test that
  the implementation is correct? One possibility is to use <a href=
  "http://en.wikipedia.org/wiki/Numerical_differentiation">numerical
  differentiation</a>. The simplest method is directly based on the definition
  of the derivative:</p>

  <p>\( f'(x) \approx \frac{f(x + h) - f(x)}{h} \) for some small \(h\)</p>

  <p>Although trivial to implement, this method suffers from several issues
  such as the difficulty of selecting \(h\) especially for \(x = 0\). So I used
  the Ridders' method described in the book <a href=
  "http://www.amazon.com/Numerical-Recipes-Scientific-Computing-Edition/dp/0521431085">
  Numerical Recipes in C: The Art of Scientific Computing</a>. This methods
  starts from large \(h\) and successfully decreases it estimating error at
  each iteration.</p>

  <p>Numerical differentiation proved to be very useful for testing. Although
  it took some time to implement the <a href=
  "https://github.com/vitaut/ampl/blob/master/tests/function.h">test
  infrastructure</a>, it paid off by catching a number of bugs and corner
  cases. And now that the test infrastructure is in place, adding tests for new
  functions requires minimal amount of code.</p>
</div>
